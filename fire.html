<!DOCTYPE html>
<html lang="en">
<head>
  <title>Firedemo reprise</title>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <style type="text/css">
    body {
      background-color: black;
      color: white;
    }

    .interactive {
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    .fullscreen {
      position: absolute;
      bottom: 0;
      left: 0;
      display: block;
      padding: 0;
      border: 0;
      margin: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body class="fullscreen">
<canvas id="canvas" class="fullscreen interactive"></canvas>
<script>
  // Select a fast numeric array where available. (from Tojiro's gl-matrix)
  let MAT_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;

  let FirePalette = (function () {
    // The original hand-rolled palette
    let pal = [
      0, 0, 0, 0, 1, 1, 0, 4, 5, 0, 7, 9,
      0, 8, 11, 0, 9, 12, 15, 6, 8, 25, 4, 4,
      33, 3, 3, 40, 2, 2, 48, 2, 2, 55, 1, 1,
      63, 0, 0, 63, 0, 0, 63, 3, 0, 63, 7, 0,
      63, 10, 0, 63, 13, 0, 63, 16, 0, 63, 20, 0,
      63, 23, 0, 63, 26, 0, 63, 29, 0, 63, 33, 0,
      63, 36, 0, 63, 39, 0, 63, 39, 0, 63, 40, 0,
      63, 40, 0, 63, 41, 0, 63, 42, 0, 63, 42, 0,
      63, 43, 0, 63, 44, 0, 63, 44, 0, 63, 45, 0,
      63, 45, 0, 63, 46, 0, 63, 47, 0, 63, 47, 0,
      63, 48, 0, 63, 49, 0, 63, 49, 0, 63, 50, 0,
      63, 51, 0, 63, 51, 0, 63, 52, 0, 63, 53, 0,
      63, 53, 0, 63, 54, 0, 63, 55, 0, 63, 55, 0,
      63, 56, 0, 63, 57, 0, 63, 57, 0, 63, 58, 0,
      63, 58, 0, 63, 59, 0, 63, 60, 0, 63, 60, 0,
      63, 61, 0, 63, 62, 0, 63, 62, 0, 63, 63, 0];
    let realPalette = new MAT_TYPE(256 * 3);
    let i = 0;
    for (; i < pal.length; ++i) {
      realPalette[i] = Math.floor(pal[i] * 255 / 63);
    }
    // Fill the upper 192 entries with pure white
    for (; i < realPalette.length; ++i) {
      realPalette[i] = 255;
    }
    return realPalette;
  })();

  let Fire = function () {
    this.w = 128;
    this.h = 72;
  }

  Fire.prototype.Reset = function () {
    let s = this.w * this.h;

    function makeBuf() {
      let g = new MAT_TYPE(s);
      for (let j = 0; j < s; ++j) {
        g[j] = 0;
      }
      return g;
    }

    this.backbuffer = makeBuf();
    this.tempbuffer = makeBuf();
  }

  Fire.prototype.tick = function () {
    let src = this.backbuffer;
    let temp = this.tempbuffer;
    let w = this.w;
    let h = this.h;

    // Transform backbuffer spreading the heat, cooling down and randomly creating sparks below
    let max = w * (h - 1) - 1;
    let coolmax = w * (h - 4);
    for (let i = w + 1; i < max; ++i) {
      // Average neighbours - this spreads the heat
      let v = src[i - 1 - w] + src[i - w] + src[i + 1 - w] + src[i - 1] + src[i + 1] + src[i - 1 + w] + src[i + w] + src[i + 1 + w];
      let finalv = Math.floor(v / 8);
      // 25% of cells in a more or less random selection will be cooled
      let bcool = v & 3;
      // We cool cells only if they are not zero already - *except* in the lower lines of the buffer
      // Cooling zero pixels in the lower area will 'wrap around' into random hot pixels
      // Incidentally, in the beginning all pixels wrap, meaning a big explosion
      if (!bcool && (i >= coolmax || finalv > 0)) {
        finalv = (255 + finalv) % 256;
      }
      temp[i] = finalv;
    }
    // Scroll up & copy back the results
    max = w * (h - 2);
    for (let x = 0; x < max; ++x) {
      src[x] = temp[x + w];
    }
    // Smooth bottom rows - just for rendering
    max = w * (h - 1);
    for (let x = w * (h - 7); x < max; ++x) {
      if (temp[x] < 15)
        temp[x] = (256 - temp[x] + 22) % 256;
    }
  }

  Fire.prototype.render = function (dest) {
    // Scroll up & render the results. The last row is blank and can be skipped.
    let s = this.w * (this.h - 2);
    let w = this.w;
    let g = this.tempbuffer;
    for (let j = 0, i = 0; j < s; ++j, i += 4) {
      dest[i] = FirePalette[g[j + w] * 3];
      dest[i + 1] = FirePalette[g[j + w] * 3 + 1];
      dest[i + 2] = FirePalette[g[j + w] * 3 + 2];
      dest[i + 3] = 255;
    }
  }

  // Helper to provides requestAnimationFrame in a cross browser way.
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = (function () {
      return window.webkitRequestAnimationFrame ||
              function (callback) {
                window.setTimeout(callback, 1000 / 60);
              };
    })();
  }

  window.onload = function () {
    let fire = new Fire();
    fire.Reset();
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");
    canvas.width = fire.w;
    canvas.height = fire.h - 2; // The two bottom lines are empty.

    // Prevent panning & make canvas clickable
    document.addEventListener("touchmove", function (e) {
      e.preventDefault();
    })

    let id = ctx.createImageData(canvas.width, canvas.height);

    // Main loop
    let tick = function () {
      fire.tick();
      fire.render(id.data);
      ctx.putImageData(id, 0, 0);
      requestAnimationFrame(tick);
    }
    tick(); // Go!
  }
</script>
</body>
</html>
